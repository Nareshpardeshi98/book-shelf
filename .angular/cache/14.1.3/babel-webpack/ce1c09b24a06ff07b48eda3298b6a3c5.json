{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isSqlQuery = exports.SQLItemType = void 0;\nvar SQLItemType;\n\n(function (SQLItemType) {\n  SQLItemType[SQLItemType[\"RAW\"] = 0] = \"RAW\";\n  SQLItemType[SQLItemType[\"VALUE\"] = 1] = \"VALUE\";\n  SQLItemType[SQLItemType[\"IDENTIFIER\"] = 2] = \"IDENTIFIER\";\n})(SQLItemType = exports.SQLItemType || (exports.SQLItemType = {}));\n\nconst formatter = Symbol('SQL Query Formatter');\nconst literalSeparators = new Set(['', ',', ', ', ' AND ', ' OR ', ') AND (', ') OR (', ';']);\n/**\n * The representation of a SQL query. Call `compile` to turn it into a SQL\n * string with value placeholders.\n *\n * This object is immutable. Instead of changing the object, new `SQLQuery`\n * values will be returned.\n *\n * The constructor for this class is private and may not be called.\n */\n\nclass SQLQuery {\n  // The constructor is private. Users should use the static `create` method to\n  // make a new `SQLQuery`.\n  constructor(items) {\n    this._cache = new Map();\n    this._items = items;\n  }\n\n  static registerFormatter(constructor, format) {\n    constructor.prototype[formatter] = format;\n  }\n  /**\n   * A template string tag that interpolates literal SQL with placeholder SQL\n   * values.\n   */\n\n\n  static query(strings, ...values) {\n    const items = []; // Add all of the strings as raw items and values as placeholder values.\n\n    for (let i = 0; i < strings.length; i++) {\n      if (strings[i]) {\n        items.push({\n          type: SQLItemType.RAW,\n          text: strings[i]\n        });\n      }\n\n      if (i < values.length) {\n        const value = values[i]; // If the value is a `SQLQuery`, add all of its items.\n\n        if (value instanceof SQLQuery) {\n          for (const item of value._items) items.push(item);\n        } else {\n          if (value && typeof value === 'object' && formatter in value) {\n            const formatted = value[formatter](value);\n\n            if (!(formatted instanceof SQLQuery)) {\n              throw new Error('Formatters should always return SQLQuery objects');\n            }\n\n            for (const item of formatted._items) items.push(item);\n          } else {\n            const before = strings[i][strings[i].length - 1];\n            const after = strings.length > i + 1 ? strings[i + 1][0] : undefined;\n\n            if (after && (before === `'` && after === `'` || before === `\"` && after === `\"` || before === '`' && after === '`')) {\n              throw new Error(`You do not need to wrap values in 'quotes' when using @databases. Any JavaScript string passed via \\${...} syntax is already treated as a string. Please remove the quotes around this value.`);\n            }\n\n            if (typeof value === 'bigint') {\n              items.push({\n                type: SQLItemType.VALUE,\n                value: value.toString(10)\n              });\n            } else {\n              items.push({\n                type: SQLItemType.VALUE,\n                value\n              });\n            }\n          }\n        }\n      }\n    }\n\n    return new SQLQuery(items);\n  }\n  /**\n   * Joins multiple queries together and puts a separator in between if a\n   * separator was defined.\n   */\n\n\n  static join(queries, separator) {\n    if (typeof separator === 'string' && !literalSeparators.has(separator)) {\n      throw new Error(`Please tag your string as an SQL query via \"sql.join(..., sql\\`${separator.includes('`') ? 'your_separator' : separator}\\`)\" or use one of the standard speparators: ${[...literalSeparators].map(s => `\"${s}\"`).join(', ')}`);\n    }\n\n    const items = [];\n    const separatorItems = separator ? typeof separator === 'string' ? [{\n      type: SQLItemType.RAW,\n      text: separator\n    }] : separator._items : undefined;\n    let addedFirst = false; // Add the items of all our queries into the `items` array, adding text\n    // separator items as necessary.\n\n    for (const query of queries) {\n      if (!addedFirst) {\n        addedFirst = true;\n      } else if (separatorItems) {\n        items.push(...separatorItems);\n      }\n\n      items.push(...query._items);\n    }\n\n    return new SQLQuery(items);\n  }\n  /**\n   * Creates a new query with the raw text.\n   */\n\n\n  static __dangerous__rawValue(text) {\n    return new SQLQuery([{\n      type: SQLItemType.RAW,\n      text\n    }]);\n  }\n  /**\n   * Creates a new query from the array of `SQLItem` parts\n   */\n\n\n  static __dangerous__constructFromParts(items) {\n    return new SQLQuery(items);\n  }\n  /**\n   * Creates a new query with the value. This value will be turned into a\n   * placeholder when the query gets compiled.\n   */\n\n\n  static value(value) {\n    return new SQLQuery([{\n      type: SQLItemType.VALUE,\n      value\n    }]);\n  }\n  /**\n   * Creates an identifier query. Each name will be escaped, and the\n   * names will be concatenated with a period (`.`).\n   */\n\n\n  static ident(...names) {\n    return new SQLQuery([{\n      type: SQLItemType.IDENTIFIER,\n      names\n    }]);\n  }\n\n  format(formatter) {\n    const cached = this._cache.get(formatter);\n\n    if (cached) return cached;\n    const fresh = typeof formatter === 'function' ? formatter(this._items) : formatStandard(this._items, formatter);\n\n    this._cache.set(formatter, fresh);\n\n    return fresh;\n  }\n\n}\n\nfunction formatStandard(items, {\n  escapeIdentifier,\n  formatValue\n}) {\n  // Create an empty query object.\n  let text = '';\n  const values = [];\n  const localIdentifiers = new Map();\n\n  for (const item of items) {\n    switch (item.type) {\n      // If this is just raw text, we add it directly to the query text.\n      case SQLItemType.RAW:\n        {\n          text += item.text;\n          break;\n        }\n      // If we got a value SQL item, add a placeholder and add the value to our\n      // placeholder values array.\n\n      case SQLItemType.VALUE:\n        {\n          const {\n            placeholder,\n            value\n          } = formatValue(item.value, values.length);\n          text += placeholder;\n          values.push(value);\n          break;\n        }\n      // If we got an identifier type, escape the strings and get a local\n      // identifier for non-string identifiers.\n\n      case SQLItemType.IDENTIFIER:\n        {\n          text += item.names.map(name => {\n            if (typeof name === 'string') return escapeIdentifier(name);\n            if (!localIdentifiers.has(name)) localIdentifiers.set(name, `__local_${localIdentifiers.size}__`);\n            return escapeIdentifier(localIdentifiers.get(name));\n          }).join('.');\n          break;\n        }\n    }\n  }\n\n  if (text.trim()) {\n    const lines = text.split('\\n');\n    const min = Math.min(...lines.filter(l => l.trim() !== '').map(l => /^\\s*/.exec(l)[0].length));\n\n    if (min) {\n      text = lines.map(line => line.substr(min)).join('\\n');\n    }\n  }\n\n  return {\n    text: text.trim(),\n    values\n  };\n} // tslint:disable:no-unbound-method\n// Create the SQL interface we export.\n\n\nconst sql = Object.assign(SQLQuery.query, {\n  join: SQLQuery.join,\n  __dangerous__rawValue: SQLQuery.__dangerous__rawValue,\n  __dangerous__constructFromParts: SQLQuery.__dangerous__constructFromParts,\n  value: SQLQuery.value,\n  ident: SQLQuery.ident,\n  registerFormatter: SQLQuery.registerFormatter\n}); // tslint:enable:no-unbound-method\n\nexports.default = sql;\n\nfunction isSqlQuery(query) {\n  return query instanceof SQLQuery;\n}\n\nexports.isSqlQuery = isSqlQuery;\nmodule.exports = sql;\nmodule.exports.default = sql;\nmodule.exports.isSqlQuery = isSqlQuery;\nmodule.exports.SQLItemType = SQLItemType;","map":{"version":3,"names":["Object","defineProperty","exports","value","isSqlQuery","SQLItemType","formatter","Symbol","literalSeparators","Set","SQLQuery","constructor","items","_cache","Map","_items","registerFormatter","format","prototype","query","strings","values","i","length","push","type","RAW","text","item","formatted","Error","before","after","undefined","VALUE","toString","join","queries","separator","has","includes","map","s","separatorItems","addedFirst","__dangerous__rawValue","__dangerous__constructFromParts","ident","names","IDENTIFIER","cached","get","fresh","formatStandard","set","escapeIdentifier","formatValue","localIdentifiers","placeholder","name","size","trim","lines","split","min","Math","filter","l","exec","line","substr","sql","assign","default","module"],"sources":["D:/angular/pr1/node_modules/@databases/sql/lib/web.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isSqlQuery = exports.SQLItemType = void 0;\nvar SQLItemType;\n(function (SQLItemType) {\n    SQLItemType[SQLItemType[\"RAW\"] = 0] = \"RAW\";\n    SQLItemType[SQLItemType[\"VALUE\"] = 1] = \"VALUE\";\n    SQLItemType[SQLItemType[\"IDENTIFIER\"] = 2] = \"IDENTIFIER\";\n})(SQLItemType = exports.SQLItemType || (exports.SQLItemType = {}));\nconst formatter = Symbol('SQL Query Formatter');\nconst literalSeparators = new Set([\n    '',\n    ',',\n    ', ',\n    ' AND ',\n    ' OR ',\n    ') AND (',\n    ') OR (',\n    ';',\n]);\n/**\n * The representation of a SQL query. Call `compile` to turn it into a SQL\n * string with value placeholders.\n *\n * This object is immutable. Instead of changing the object, new `SQLQuery`\n * values will be returned.\n *\n * The constructor for this class is private and may not be called.\n */\nclass SQLQuery {\n    // The constructor is private. Users should use the static `create` method to\n    // make a new `SQLQuery`.\n    constructor(items) {\n        this._cache = new Map();\n        this._items = items;\n    }\n    static registerFormatter(constructor, format) {\n        constructor.prototype[formatter] = format;\n    }\n    /**\n     * A template string tag that interpolates literal SQL with placeholder SQL\n     * values.\n     */\n    static query(strings, ...values) {\n        const items = [];\n        // Add all of the strings as raw items and values as placeholder values.\n        for (let i = 0; i < strings.length; i++) {\n            if (strings[i]) {\n                items.push({ type: SQLItemType.RAW, text: strings[i] });\n            }\n            if (i < values.length) {\n                const value = values[i];\n                // If the value is a `SQLQuery`, add all of its items.\n                if (value instanceof SQLQuery) {\n                    for (const item of value._items)\n                        items.push(item);\n                }\n                else {\n                    if (value && typeof value === 'object' && formatter in value) {\n                        const formatted = value[formatter](value);\n                        if (!(formatted instanceof SQLQuery)) {\n                            throw new Error('Formatters should always return SQLQuery objects');\n                        }\n                        for (const item of formatted._items)\n                            items.push(item);\n                    }\n                    else {\n                        const before = strings[i][strings[i].length - 1];\n                        const after = strings.length > i + 1 ? strings[i + 1][0] : undefined;\n                        if (after &&\n                            ((before === `'` && after === `'`) ||\n                                (before === `\"` && after === `\"`) ||\n                                (before === '`' && after === '`'))) {\n                            throw new Error(`You do not need to wrap values in 'quotes' when using @databases. Any JavaScript string passed via \\${...} syntax is already treated as a string. Please remove the quotes around this value.`);\n                        }\n                        if (typeof value === 'bigint') {\n                            items.push({ type: SQLItemType.VALUE, value: value.toString(10) });\n                        }\n                        else {\n                            items.push({ type: SQLItemType.VALUE, value });\n                        }\n                    }\n                }\n            }\n        }\n        return new SQLQuery(items);\n    }\n    /**\n     * Joins multiple queries together and puts a separator in between if a\n     * separator was defined.\n     */\n    static join(queries, separator) {\n        if (typeof separator === 'string' && !literalSeparators.has(separator)) {\n            throw new Error(`Please tag your string as an SQL query via \"sql.join(..., sql\\`${separator.includes('`') ? 'your_separator' : separator}\\`)\" or use one of the standard speparators: ${[...literalSeparators]\n                .map((s) => `\"${s}\"`)\n                .join(', ')}`);\n        }\n        const items = [];\n        const separatorItems = separator\n            ? typeof separator === 'string'\n                ? [{ type: SQLItemType.RAW, text: separator }]\n                : separator._items\n            : undefined;\n        let addedFirst = false;\n        // Add the items of all our queries into the `items` array, adding text\n        // separator items as necessary.\n        for (const query of queries) {\n            if (!addedFirst) {\n                addedFirst = true;\n            }\n            else if (separatorItems) {\n                items.push(...separatorItems);\n            }\n            items.push(...query._items);\n        }\n        return new SQLQuery(items);\n    }\n    /**\n     * Creates a new query with the raw text.\n     */\n    static __dangerous__rawValue(text) {\n        return new SQLQuery([{ type: SQLItemType.RAW, text }]);\n    }\n    /**\n     * Creates a new query from the array of `SQLItem` parts\n     */\n    static __dangerous__constructFromParts(items) {\n        return new SQLQuery(items);\n    }\n    /**\n     * Creates a new query with the value. This value will be turned into a\n     * placeholder when the query gets compiled.\n     */\n    static value(value) {\n        return new SQLQuery([{ type: SQLItemType.VALUE, value }]);\n    }\n    /**\n     * Creates an identifier query. Each name will be escaped, and the\n     * names will be concatenated with a period (`.`).\n     */\n    static ident(...names) {\n        return new SQLQuery([{ type: SQLItemType.IDENTIFIER, names }]);\n    }\n    format(formatter) {\n        const cached = this._cache.get(formatter);\n        if (cached)\n            return cached;\n        const fresh = typeof formatter === 'function'\n            ? formatter(this._items)\n            : formatStandard(this._items, formatter);\n        this._cache.set(formatter, fresh);\n        return fresh;\n    }\n}\nfunction formatStandard(items, { escapeIdentifier, formatValue }) {\n    // Create an empty query object.\n    let text = '';\n    const values = [];\n    const localIdentifiers = new Map();\n    for (const item of items) {\n        switch (item.type) {\n            // If this is just raw text, we add it directly to the query text.\n            case SQLItemType.RAW: {\n                text += item.text;\n                break;\n            }\n            // If we got a value SQL item, add a placeholder and add the value to our\n            // placeholder values array.\n            case SQLItemType.VALUE: {\n                const { placeholder, value } = formatValue(item.value, values.length);\n                text += placeholder;\n                values.push(value);\n                break;\n            }\n            // If we got an identifier type, escape the strings and get a local\n            // identifier for non-string identifiers.\n            case SQLItemType.IDENTIFIER: {\n                text += item.names\n                    .map((name) => {\n                    if (typeof name === 'string')\n                        return escapeIdentifier(name);\n                    if (!localIdentifiers.has(name))\n                        localIdentifiers.set(name, `__local_${localIdentifiers.size}__`);\n                    return escapeIdentifier(localIdentifiers.get(name));\n                })\n                    .join('.');\n                break;\n            }\n        }\n    }\n    if (text.trim()) {\n        const lines = text.split('\\n');\n        const min = Math.min(...lines\n            .filter((l) => l.trim() !== '')\n            .map((l) => /^\\s*/.exec(l)[0].length));\n        if (min) {\n            text = lines.map((line) => line.substr(min)).join('\\n');\n        }\n    }\n    return { text: text.trim(), values };\n}\n// tslint:disable:no-unbound-method\n// Create the SQL interface we export.\nconst sql = Object.assign(SQLQuery.query, {\n    join: SQLQuery.join,\n    __dangerous__rawValue: SQLQuery.__dangerous__rawValue,\n    __dangerous__constructFromParts: SQLQuery.__dangerous__constructFromParts,\n    value: SQLQuery.value,\n    ident: SQLQuery.ident,\n    registerFormatter: SQLQuery.registerFormatter,\n});\n// tslint:enable:no-unbound-method\nexports.default = sql;\nfunction isSqlQuery(query) {\n    return query instanceof SQLQuery;\n}\nexports.isSqlQuery = isSqlQuery;\nmodule.exports = sql;\nmodule.exports.default = sql;\nmodule.exports.isSqlQuery = isSqlQuery;\nmodule.exports.SQLItemType = SQLItemType;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
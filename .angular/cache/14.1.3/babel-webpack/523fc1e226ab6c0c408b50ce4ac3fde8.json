{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"D:/angular/pr1/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst queue_1 = require(\"@databases/queue\");\n\nconst defer_1 = require(\"./utils/defer\");\n\nconst errors_1 = require(\"./utils/errors\");\n\nconst timeout_1 = require(\"./utils/timeout\");\n\nconst Waiter_1 = require(\"./utils/Waiter\");\n\nconst IPoolRecord_1 = require(\"./IPoolRecord\");\n\nconst PoolOptions_1 = require(\"./PoolOptions\");\n\nconst RESOLVED_PROMISE = Promise.resolve();\n\nclass PoolConnectionImpl {\n  constructor(record, pool, onReleaseTimeout, releaseTimeoutMilliseconds) {\n    this._released = false;\n    this._timedOut = false;\n    this.connection = record.connection;\n    this._record = record;\n    this._pool = pool;\n\n    if (releaseTimeoutMilliseconds !== Infinity) {\n      this._timeout = setTimeout(() => {\n        this._timedOut = true;\n        onReleaseTimeout(record);\n      }, releaseTimeoutMilliseconds);\n    }\n  }\n\n  release() {\n    if (this._timedOut) {\n      return;\n    }\n\n    if (this._timeout !== undefined) {\n      clearTimeout(this._timeout);\n    }\n\n    if (this._released) {\n      throw (0, errors_1.doubleReleaseError)();\n    }\n\n    this._released = true;\n\n    this._pool._releaseConnection(this._record);\n  }\n\n  dispose() {\n    if (this._timedOut) {\n      return;\n    }\n\n    if (this._timeout !== undefined) {\n      clearTimeout(this._timeout);\n    }\n\n    if (this._released) {\n      throw (0, errors_1.doubleReleaseError)();\n    }\n\n    this._released = true;\n\n    this._pool._closeConnection(this._record);\n  }\n\n}\n\nclass ConnectionPoolState {\n  constructor(options) {\n    this._isDraining = false;\n    this._totalConnectionsCount = 0;\n    this._idleConnections = new queue_1.default();\n    this._waiters = new queue_1.default();\n\n    this._onIdleTimeout = record => {\n      this._closeConnection(record);\n    };\n\n    this._onReleaseTimeout = record => {\n      const connection = record.connection;\n      (0, IPoolRecord_1.setRecordState)(record, IPoolRecord_1.PoolRecordState.Disposed);\n\n      this._decreaseTotalConnectionsCount();\n\n      this._options.onReleaseTimeout(connection);\n    };\n\n    this._options = options;\n    const [drained, onDrained] = (0, defer_1.default)();\n    this._drained = drained;\n    this._onDrained = onDrained;\n  }\n\n  _increaseTotalConnectionsCount() {\n    this._totalConnectionsCount++;\n  }\n\n  _decreaseTotalConnectionsCount() {\n    this._totalConnectionsCount--;\n\n    const nextWaiter = this._getNextWaiter();\n\n    if (nextWaiter) {\n      nextWaiter.resolve(this._openConnection());\n    }\n\n    if (this._isDraining && this._totalConnectionsCount === 0) {\n      this._onDrained();\n    }\n  }\n\n  _canOpenConnection() {\n    if (!this._options.maxSize) return true;\n    return this._totalConnectionsCount < this._options.maxSize;\n  }\n\n  _openConnection() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const [destroyed, destroy] = (0, defer_1.default)();\n\n      _this._increaseTotalConnectionsCount();\n\n      return RESOLVED_PROMISE.then(() => _this._options.openConnection(destroy)).then(connection => {\n        if ((0, timeout_1.isTimeout)(connection)) {\n          throw (0, errors_1.openTimeout)();\n        }\n\n        const record = (0, IPoolRecord_1.getPoolRecord)(connection);\n        const r = record;\n        void destroyed.then(() => {\n          if ((0, IPoolRecord_1.isActivePoolRecord)(r)) {\n            r.shouldDestroy = true;\n          } else if ((0, IPoolRecord_1.isIdlePoolRecord)(r)) {\n            _this._closeConnection(r);\n          }\n        });\n        return record;\n      }).catch(err => {\n        if (_this._totalConnectionsCount > 1 && _this._options.isConnectionLimitError(err)) {\n          _this._totalConnectionsCount--;\n          const maxSizeReduction = _this._options.maxSize - _this._totalConnectionsCount;\n          _this._options.maxSize -= maxSizeReduction;\n          setTimeout(() => {\n            _this._totalConnectionsCount++;\n            _this._options.maxSize += maxSizeReduction;\n\n            _this._decreaseTotalConnectionsCount();\n\n            return errors_1.connectionLimitExceeded;\n          }, _this._options.connectionLimitBackoffMilliseconds);\n          return errors_1.connectionLimitExceeded;\n        }\n\n        _this._decreaseTotalConnectionsCount();\n\n        throw err;\n      });\n    })();\n  }\n\n  _releaseConnection(record) {\n    if (!(0, IPoolRecord_1.isActivePoolRecord)(record)) {\n      throw new Error('Cannot call releaseConnection when record that is not active');\n    }\n\n    if (record.shouldDestroy || record.activateCount >= this._options.maxUses) {\n      this._closeConnection(record);\n\n      return;\n    }\n\n    const waiter = this._getNextWaiter();\n\n    if (waiter) {\n      waiter.resolve(record);\n    } else if (this._isDraining) {\n      this._closeConnection(record);\n    } else {\n      const err = this._options.onIdle(record.connection);\n\n      if (err) {\n        this._decreaseTotalConnectionsCount();\n\n        throw err;\n      }\n\n      this._idleConnections.push((0, IPoolRecord_1.setRecordState)(record, IPoolRecord_1.PoolRecordState.Idle, this._onIdleTimeout, this._options.idleTimeoutMilliseconds));\n    }\n  }\n\n  _closeConnection(record) {\n    const connection = record.connection;\n\n    if ((0, IPoolRecord_1.isDisposedPoolRecord)(record)) {\n      throw new Error('Cannot call closeConnection when record is already disposed');\n    }\n\n    (0, IPoolRecord_1.setRecordState)(record, IPoolRecord_1.PoolRecordState.Disposed);\n\n    this._options.closeConnection(connection).then(() => {\n      this._decreaseTotalConnectionsCount();\n    }, () => {\n      this._decreaseTotalConnectionsCount();\n    });\n  }\n\n  _getNextIdleRecord() {\n    while (true) {\n      const record = this._idleConnections.shift();\n\n      if (record === undefined || (0, IPoolRecord_1.isIdlePoolRecord)(record)) {\n        return record;\n      }\n    }\n  }\n\n  _getNextWaiter() {\n    while (true) {\n      const record = this._waiters.shift();\n\n      if (record === undefined || !record.isTimedOut()) {\n        return record;\n      }\n    }\n  }\n  /**\n   * Retrieve a connection from the connection pool.\n   *\n   * N.B. you must call either `release` or `dispose`\n   * otherwise your connection pool will eventually\n   * be stuck and your app will stall.\n   */\n\n\n  getConnection() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const record = (_a = _this2._getNextIdleRecord()) !== null && _a !== void 0 ? _a : _this2._canOpenConnection() ? yield _this2._openConnection() : yield new Promise(resolve => {\n        _this2._waiters.push(new Waiter_1.default(resolve, _this2._options.queueTimeoutMilliseconds));\n      });\n\n      if (record === errors_1.connectionLimitExceeded) {\n        return yield _this2.getConnection();\n      }\n\n      if ((0, timeout_1.isTimeout)(record)) {\n        throw (0, errors_1.queueTimeoutError)();\n      }\n\n      if ((0, IPoolRecord_1.isIdlePoolRecord)(record)) {\n        const err = _this2._options.onActive(record.connection);\n\n        if (err) {\n          _this2._decreaseTotalConnectionsCount();\n\n          throw err;\n        }\n      }\n\n      const activeRecord = (0, IPoolRecord_1.setRecordState)(record, IPoolRecord_1.PoolRecordState.Active);\n      return new PoolConnectionImpl(activeRecord, _this2, _this2._onReleaseTimeout, _this2._options.releaseTimeoutMilliseconds);\n    })();\n  }\n  /**\n   * How many connections are currently active, both\n   * idle connections in the pool, and connections that\n   * are in use.\n   */\n\n\n  getConnectionsCount() {\n    return this._totalConnectionsCount;\n  }\n  /**\n   * How many connections are active, but not currently\n   * in use.\n   *\n   * TODO: this may not be accurate\n   */\n\n\n  getIdleConnectionsCount() {\n    return this._idleConnections.getLength();\n  }\n  /**\n   * How many processes are in the queue waiting for\n   * a connection.\n   */\n\n\n  getQueueLength() {\n    return this._waiters.getLength();\n  }\n\n  drain() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      _this3._isDraining = true;\n\n      for (const connection of _this3._idleConnections.clear()) {\n        if ((0, IPoolRecord_1.isIdlePoolRecord)(connection)) {\n          _this3._closeConnection(connection);\n        }\n      }\n\n      if (_this3._totalConnectionsCount === 0) {\n        _this3._onDrained();\n      }\n\n      yield _this3._drained;\n    })();\n  }\n\n}\n/**\n * Create a new ConnectionPool to manage connections\n */\n\n\nfunction createConnectionPool(options) {\n  return new ConnectionPoolState(new PoolOptions_1.PoolOptionsObject(options));\n}\n\nexports.default = createConnectionPool;\nmodule.exports = Object.assign(createConnectionPool, {\n  default: createConnectionPool\n});","map":{"version":3,"names":["Object","defineProperty","exports","value","queue_1","require","defer_1","errors_1","timeout_1","Waiter_1","IPoolRecord_1","PoolOptions_1","RESOLVED_PROMISE","Promise","resolve","PoolConnectionImpl","constructor","record","pool","onReleaseTimeout","releaseTimeoutMilliseconds","_released","_timedOut","connection","_record","_pool","Infinity","_timeout","setTimeout","release","undefined","clearTimeout","doubleReleaseError","_releaseConnection","dispose","_closeConnection","ConnectionPoolState","options","_isDraining","_totalConnectionsCount","_idleConnections","default","_waiters","_onIdleTimeout","_onReleaseTimeout","setRecordState","PoolRecordState","Disposed","_decreaseTotalConnectionsCount","_options","drained","onDrained","_drained","_onDrained","_increaseTotalConnectionsCount","nextWaiter","_getNextWaiter","_openConnection","_canOpenConnection","maxSize","destroyed","destroy","then","openConnection","isTimeout","openTimeout","getPoolRecord","r","isActivePoolRecord","shouldDestroy","isIdlePoolRecord","catch","err","isConnectionLimitError","maxSizeReduction","connectionLimitExceeded","connectionLimitBackoffMilliseconds","Error","activateCount","maxUses","waiter","onIdle","push","Idle","idleTimeoutMilliseconds","isDisposedPoolRecord","closeConnection","_getNextIdleRecord","shift","isTimedOut","getConnection","_a","queueTimeoutMilliseconds","queueTimeoutError","onActive","activeRecord","Active","getConnectionsCount","getIdleConnectionsCount","getLength","getQueueLength","drain","clear","createConnectionPool","PoolOptionsObject","module","assign"],"sources":["D:/angular/pr1/node_modules/@databases/connection-pool/lib/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst queue_1 = require(\"@databases/queue\");\nconst defer_1 = require(\"./utils/defer\");\nconst errors_1 = require(\"./utils/errors\");\nconst timeout_1 = require(\"./utils/timeout\");\nconst Waiter_1 = require(\"./utils/Waiter\");\nconst IPoolRecord_1 = require(\"./IPoolRecord\");\nconst PoolOptions_1 = require(\"./PoolOptions\");\nconst RESOLVED_PROMISE = Promise.resolve();\nclass PoolConnectionImpl {\n    constructor(record, pool, onReleaseTimeout, releaseTimeoutMilliseconds) {\n        this._released = false;\n        this._timedOut = false;\n        this.connection = record.connection;\n        this._record = record;\n        this._pool = pool;\n        if (releaseTimeoutMilliseconds !== Infinity) {\n            this._timeout = setTimeout(() => {\n                this._timedOut = true;\n                onReleaseTimeout(record);\n            }, releaseTimeoutMilliseconds);\n        }\n    }\n    release() {\n        if (this._timedOut) {\n            return;\n        }\n        if (this._timeout !== undefined) {\n            clearTimeout(this._timeout);\n        }\n        if (this._released) {\n            throw (0, errors_1.doubleReleaseError)();\n        }\n        this._released = true;\n        this._pool._releaseConnection(this._record);\n    }\n    dispose() {\n        if (this._timedOut) {\n            return;\n        }\n        if (this._timeout !== undefined) {\n            clearTimeout(this._timeout);\n        }\n        if (this._released) {\n            throw (0, errors_1.doubleReleaseError)();\n        }\n        this._released = true;\n        this._pool._closeConnection(this._record);\n    }\n}\nclass ConnectionPoolState {\n    constructor(options) {\n        this._isDraining = false;\n        this._totalConnectionsCount = 0;\n        this._idleConnections = new queue_1.default();\n        this._waiters = new queue_1.default();\n        this._onIdleTimeout = (record) => {\n            this._closeConnection(record);\n        };\n        this._onReleaseTimeout = (record) => {\n            const connection = record.connection;\n            (0, IPoolRecord_1.setRecordState)(record, IPoolRecord_1.PoolRecordState.Disposed);\n            this._decreaseTotalConnectionsCount();\n            this._options.onReleaseTimeout(connection);\n        };\n        this._options = options;\n        const [drained, onDrained] = (0, defer_1.default)();\n        this._drained = drained;\n        this._onDrained = onDrained;\n    }\n    _increaseTotalConnectionsCount() {\n        this._totalConnectionsCount++;\n    }\n    _decreaseTotalConnectionsCount() {\n        this._totalConnectionsCount--;\n        const nextWaiter = this._getNextWaiter();\n        if (nextWaiter) {\n            nextWaiter.resolve(this._openConnection());\n        }\n        if (this._isDraining && this._totalConnectionsCount === 0) {\n            this._onDrained();\n        }\n    }\n    _canOpenConnection() {\n        if (!this._options.maxSize)\n            return true;\n        return this._totalConnectionsCount < this._options.maxSize;\n    }\n    async _openConnection() {\n        const [destroyed, destroy] = (0, defer_1.default)();\n        this._increaseTotalConnectionsCount();\n        return RESOLVED_PROMISE.then(() => this._options.openConnection(destroy))\n            .then((connection) => {\n            if ((0, timeout_1.isTimeout)(connection)) {\n                throw (0, errors_1.openTimeout)();\n            }\n            const record = (0, IPoolRecord_1.getPoolRecord)(connection);\n            const r = record;\n            void destroyed.then(() => {\n                if ((0, IPoolRecord_1.isActivePoolRecord)(r)) {\n                    r.shouldDestroy = true;\n                }\n                else if ((0, IPoolRecord_1.isIdlePoolRecord)(r)) {\n                    this._closeConnection(r);\n                }\n            });\n            return record;\n        })\n            .catch((err) => {\n            if (this._totalConnectionsCount > 1 &&\n                this._options.isConnectionLimitError(err)) {\n                this._totalConnectionsCount--;\n                const maxSizeReduction = this._options.maxSize - this._totalConnectionsCount;\n                this._options.maxSize -= maxSizeReduction;\n                setTimeout(() => {\n                    this._totalConnectionsCount++;\n                    this._options.maxSize += maxSizeReduction;\n                    this._decreaseTotalConnectionsCount();\n                    return errors_1.connectionLimitExceeded;\n                }, this._options.connectionLimitBackoffMilliseconds);\n                return errors_1.connectionLimitExceeded;\n            }\n            this._decreaseTotalConnectionsCount();\n            throw err;\n        });\n    }\n    _releaseConnection(record) {\n        if (!(0, IPoolRecord_1.isActivePoolRecord)(record)) {\n            throw new Error('Cannot call releaseConnection when record that is not active');\n        }\n        if (record.shouldDestroy || record.activateCount >= this._options.maxUses) {\n            this._closeConnection(record);\n            return;\n        }\n        const waiter = this._getNextWaiter();\n        if (waiter) {\n            waiter.resolve(record);\n        }\n        else if (this._isDraining) {\n            this._closeConnection(record);\n        }\n        else {\n            const err = this._options.onIdle(record.connection);\n            if (err) {\n                this._decreaseTotalConnectionsCount();\n                throw err;\n            }\n            this._idleConnections.push((0, IPoolRecord_1.setRecordState)(record, IPoolRecord_1.PoolRecordState.Idle, this._onIdleTimeout, this._options.idleTimeoutMilliseconds));\n        }\n    }\n    _closeConnection(record) {\n        const connection = record.connection;\n        if ((0, IPoolRecord_1.isDisposedPoolRecord)(record)) {\n            throw new Error('Cannot call closeConnection when record is already disposed');\n        }\n        (0, IPoolRecord_1.setRecordState)(record, IPoolRecord_1.PoolRecordState.Disposed);\n        this._options.closeConnection(connection).then(() => {\n            this._decreaseTotalConnectionsCount();\n        }, () => {\n            this._decreaseTotalConnectionsCount();\n        });\n    }\n    _getNextIdleRecord() {\n        while (true) {\n            const record = this._idleConnections.shift();\n            if (record === undefined || (0, IPoolRecord_1.isIdlePoolRecord)(record)) {\n                return record;\n            }\n        }\n    }\n    _getNextWaiter() {\n        while (true) {\n            const record = this._waiters.shift();\n            if (record === undefined || !record.isTimedOut()) {\n                return record;\n            }\n        }\n    }\n    /**\n     * Retrieve a connection from the connection pool.\n     *\n     * N.B. you must call either `release` or `dispose`\n     * otherwise your connection pool will eventually\n     * be stuck and your app will stall.\n     */\n    async getConnection() {\n        var _a;\n        const record = (_a = this._getNextIdleRecord()) !== null && _a !== void 0 ? _a : (this._canOpenConnection()\n            ? await this._openConnection()\n            : await new Promise((resolve) => {\n                this._waiters.push(new Waiter_1.default(resolve, this._options.queueTimeoutMilliseconds));\n            }));\n        if (record === errors_1.connectionLimitExceeded) {\n            return await this.getConnection();\n        }\n        if ((0, timeout_1.isTimeout)(record)) {\n            throw (0, errors_1.queueTimeoutError)();\n        }\n        if ((0, IPoolRecord_1.isIdlePoolRecord)(record)) {\n            const err = this._options.onActive(record.connection);\n            if (err) {\n                this._decreaseTotalConnectionsCount();\n                throw err;\n            }\n        }\n        const activeRecord = (0, IPoolRecord_1.setRecordState)(record, IPoolRecord_1.PoolRecordState.Active);\n        return new PoolConnectionImpl(activeRecord, this, this._onReleaseTimeout, this._options.releaseTimeoutMilliseconds);\n    }\n    /**\n     * How many connections are currently active, both\n     * idle connections in the pool, and connections that\n     * are in use.\n     */\n    getConnectionsCount() {\n        return this._totalConnectionsCount;\n    }\n    /**\n     * How many connections are active, but not currently\n     * in use.\n     *\n     * TODO: this may not be accurate\n     */\n    getIdleConnectionsCount() {\n        return this._idleConnections.getLength();\n    }\n    /**\n     * How many processes are in the queue waiting for\n     * a connection.\n     */\n    getQueueLength() {\n        return this._waiters.getLength();\n    }\n    async drain() {\n        this._isDraining = true;\n        for (const connection of this._idleConnections.clear()) {\n            if ((0, IPoolRecord_1.isIdlePoolRecord)(connection)) {\n                this._closeConnection(connection);\n            }\n        }\n        if (this._totalConnectionsCount === 0) {\n            this._onDrained();\n        }\n        await this._drained;\n    }\n}\n/**\n * Create a new ConnectionPool to manage connections\n */\nfunction createConnectionPool(options) {\n    return new ConnectionPoolState(new PoolOptions_1.PoolOptionsObject(options));\n}\nexports.default = createConnectionPool;\nmodule.exports = Object.assign(createConnectionPool, {\n    default: createConnectionPool,\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
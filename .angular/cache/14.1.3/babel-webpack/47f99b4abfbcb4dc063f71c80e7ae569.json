{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.escapeSQLiteIdentifier = exports.escapeMySqlIdentifier = exports.escapePostgresIdentifier = void 0;\n\nconst validate_unicode_1 = require(\"@databases/validate-unicode\");\n/**\n * Escapes a Postgres identifier.\n *\n * https://www.postgresql.org/docs/9.1/sql-syntax-lexical.html\n */\n\n\nfunction escapePostgresIdentifier(str, {\n  extended = false\n} = {}) {\n  (0, validate_unicode_1.default)(str);\n  minLength(str, 'Postgres');\n  maxLength(str, 60, 'Postgres', 'https://www.postgresql.org/docs/9.3/sql-syntax-lexical.html');\n\n  if (extended) {\n    assertUnicode(str, 'Postgres');\n  } else {\n    assertAscii(str, 'Postgres', true);\n  }\n\n  return quoteString(str, `\"`);\n}\n\nexports.escapePostgresIdentifier = escapePostgresIdentifier;\n/**\n * Escapes a MySQL identifier.\n *\n * https://dev.mysql.com/doc/refman/5.7/en/identifiers.html\n */\n\nfunction escapeMySqlIdentifier(str, {\n  extended = false\n} = {}) {\n  (0, validate_unicode_1.default)(str);\n  minLength(str, 'MySQL');\n  maxLength(str, 64, 'MySQL', 'http://dev.mysql.com/doc/refman/5.7/en/identifiers.html');\n\n  if (str[str.length - 1] === ' ') {\n    throw new Error('MySQL identifiers may not end in whitespace');\n  }\n\n  if (extended) {\n    // U+0001 .. U+007F\n    // U+0080 .. U+FFFF\n    assertUnicode(str, 'MySQL');\n  } else {\n    // U+0001 .. U+007F\n    assertAscii(str, 'MySQL', true);\n  }\n\n  return quoteString(str, '`');\n}\n\nexports.escapeMySqlIdentifier = escapeMySqlIdentifier;\n/**\n * Escapes an SQLite identifier.\n *\n * https://sqlite.org/lang_keywords.html\n */\n\nfunction escapeSQLiteIdentifier(str) {\n  (0, validate_unicode_1.default)(str);\n  minLength(str, 'SQLite');\n\n  if (str.length > 63) {\n    throw new Error('SQLite identifiers are limited to 63 characters in @databases.');\n  }\n\n  assertAscii(str, 'SQLite', false);\n  return quoteString(str, `\"`);\n}\n\nexports.escapeSQLiteIdentifier = escapeSQLiteIdentifier;\n\nfunction quoteString(str, quoteChar) {\n  if (!str.includes(quoteChar)) return quoteChar + str + quoteChar;\n  return quoteChar + str.split(quoteChar).join(quoteChar + quoteChar) + quoteChar;\n}\n\nconst NON_ASCII = /[^\\u0001-\\u007f]/;\n\nfunction assertAscii(str, db, unicodeAvailable) {\n  if (NON_ASCII.test(str)) {\n    throw new Error(`${db} identifiers must only contain ASCII characters${unicodeAvailable ? ` (to use unicode, pass {extended: true} when escaping the identifier)` : ``}`);\n  }\n}\n\nconst NON_UNICODE = /[^\\u0001-\\uffff]/;\n\nfunction assertUnicode(str, db) {\n  // U+0001 .. U+007F\n  // U+0080 .. U+FFFF\n  if (NON_UNICODE.test(str)) {\n    throw new Error(`${db} identifiers must only contain characters in the range: U+0001 .. U+FFFF`);\n  }\n}\n\nfunction minLength(str, db) {\n  if (!str) {\n    throw new Error(`${db} identifiers must be at least 1 character long.`);\n  }\n}\n\nfunction maxLength(str, length, db, ref) {\n  if (str.length > length) {\n    throw new Error(`${db} identifiers must not be longer than ${length} characters. ${str}`);\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","escapeSQLiteIdentifier","escapeMySqlIdentifier","escapePostgresIdentifier","validate_unicode_1","require","str","extended","default","minLength","maxLength","assertUnicode","assertAscii","quoteString","length","Error","quoteChar","includes","split","join","NON_ASCII","db","unicodeAvailable","test","NON_UNICODE","ref"],"sources":["D:/angular/pr1/node_modules/@databases/escape-identifier/lib/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.escapeSQLiteIdentifier = exports.escapeMySqlIdentifier = exports.escapePostgresIdentifier = void 0;\nconst validate_unicode_1 = require(\"@databases/validate-unicode\");\n/**\n * Escapes a Postgres identifier.\n *\n * https://www.postgresql.org/docs/9.1/sql-syntax-lexical.html\n */\nfunction escapePostgresIdentifier(str, { extended = false } = {}) {\n    (0, validate_unicode_1.default)(str);\n    minLength(str, 'Postgres');\n    maxLength(str, 60, 'Postgres', 'https://www.postgresql.org/docs/9.3/sql-syntax-lexical.html');\n    if (extended) {\n        assertUnicode(str, 'Postgres');\n    }\n    else {\n        assertAscii(str, 'Postgres', true);\n    }\n    return quoteString(str, `\"`);\n}\nexports.escapePostgresIdentifier = escapePostgresIdentifier;\n/**\n * Escapes a MySQL identifier.\n *\n * https://dev.mysql.com/doc/refman/5.7/en/identifiers.html\n */\nfunction escapeMySqlIdentifier(str, { extended = false } = {}) {\n    (0, validate_unicode_1.default)(str);\n    minLength(str, 'MySQL');\n    maxLength(str, 64, 'MySQL', 'http://dev.mysql.com/doc/refman/5.7/en/identifiers.html');\n    if (str[str.length - 1] === ' ') {\n        throw new Error('MySQL identifiers may not end in whitespace');\n    }\n    if (extended) {\n        // U+0001 .. U+007F\n        // U+0080 .. U+FFFF\n        assertUnicode(str, 'MySQL');\n    }\n    else {\n        // U+0001 .. U+007F\n        assertAscii(str, 'MySQL', true);\n    }\n    return quoteString(str, '`');\n}\nexports.escapeMySqlIdentifier = escapeMySqlIdentifier;\n/**\n * Escapes an SQLite identifier.\n *\n * https://sqlite.org/lang_keywords.html\n */\nfunction escapeSQLiteIdentifier(str) {\n    (0, validate_unicode_1.default)(str);\n    minLength(str, 'SQLite');\n    if (str.length > 63) {\n        throw new Error('SQLite identifiers are limited to 63 characters in @databases.');\n    }\n    assertAscii(str, 'SQLite', false);\n    return quoteString(str, `\"`);\n}\nexports.escapeSQLiteIdentifier = escapeSQLiteIdentifier;\nfunction quoteString(str, quoteChar) {\n    if (!str.includes(quoteChar))\n        return quoteChar + str + quoteChar;\n    return (quoteChar + str.split(quoteChar).join(quoteChar + quoteChar) + quoteChar);\n}\nconst NON_ASCII = /[^\\u0001-\\u007f]/;\nfunction assertAscii(str, db, unicodeAvailable) {\n    if (NON_ASCII.test(str)) {\n        throw new Error(`${db} identifiers must only contain ASCII characters${unicodeAvailable\n            ? ` (to use unicode, pass {extended: true} when escaping the identifier)`\n            : ``}`);\n    }\n}\nconst NON_UNICODE = /[^\\u0001-\\uffff]/;\nfunction assertUnicode(str, db) {\n    // U+0001 .. U+007F\n    // U+0080 .. U+FFFF\n    if (NON_UNICODE.test(str)) {\n        throw new Error(`${db} identifiers must only contain characters in the range: U+0001 .. U+FFFF`);\n    }\n}\nfunction minLength(str, db) {\n    if (!str) {\n        throw new Error(`${db} identifiers must be at least 1 character long.`);\n    }\n}\nfunction maxLength(str, length, db, ref) {\n    if (str.length > length) {\n        throw new Error(`${db} identifiers must not be longer than ${length} characters. ${str}`);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}